---
title: 网络 | 当你 ping 的时候，你知道背后发生了什么吗？「转载」
date: 2020-04-30 15:40:46
categories:
- 网络
- 基础
tags:
- 网络
- network
---
基础网络知识，关于 `ping` 之后到底做了什么。

<!-- more -->

<br/>

# 参考资料

<br/>

- [当你 ping 的时候，你知道背后发生了什么吗？](https://mp.weixin.qq.com/s/bueDInZLcHb3DZwCOZF9ZQ)

<br/>

# 概览

<br/>

对于 `ping` 命令，想必只要是程序员都知道吧？当我们检查网络情况的时候，最先使用的命令肯定是 `ping` 命令吧？一般我们用 `ping` 查看网络情况，主要是检查两个指标：

- 第一个是看看是不是超时
- 第二个看看是不是延迟太高

如果超时那么肯定是网络有问题（禁 ping情况除外）；如果延迟太高，网络情况肯定也是很糟糕的。

那么对于 `ping` 命令的原理， `ping` 是如何检查网络的？大家之前有了解吗？接下来我们来跟着 `ping` 命令走一圈，看看 `ping` 是如何工作的。

<br/>

# 环境准备和抓包

<br/>

## 环境准备

抓包工具：Wireshark 准备两台电脑，进行互 ping操作：

- A电脑（IP地址： `192.168.2.135` / MAC地址： `98:22:EF:E8:A8:87`）
- B电脑（IP地址： `192.168.2.179` / MAC地址： `90:A4:DE:C2:DF:FE`）

## 抓包操作

打开 Wireshark，选取指定的网卡进行抓包，进行 ping操作，在 A电脑上 ping B电脑的 IP。

![](/images/network/1_0.png)

抓包情况如下：

![](/images/network/1_1.png)

这里先简单的介绍下Wireshark的控制面板，这个面板包含7个字段，分别是：

- NO: 编号
- Time: 包的时间戳
- Source: 源地址
- Destination: 目标地址
- Protocol: 协议
- Length: 包长度
- Info: 数据包附加信息

<br/>

# 深入解析

<br/>

上图中抓包编号 `54-132` 显示的就是整个 `ping` 命令的过程，我们知道 `ping` 命令不是依托于 TCP或者 UDP这种传输层协议的，而是依托于 `ICMP` 协议实现的， 那么什么是 `ICMP` 协议呢？这里简单介绍下：

## ICMP协议的产生背景

[RFC792]中说明了 ICMP产生的原因：由于互联网之间通讯会涉及很多网关和主机，为了能够报告数据错误，所以产生了 ICMP协议。也就是说 ICMP 协议就是为了更高效的转发 IP数据报和提高交付成功的机会。

## ICMP协议的数据格式

![](/images/network/1_2.png)

根据上图我们知道了 `ICMP协议`头包含 4个字节，头部主要用来说明类型和校验 `ICMP报文`。下图是对应的类型和代码释义列表，我们后面分析抓包的时候会用到。

|状态(Type)|编码(Code)|description|
|---|---|---|
|0|0|回声应答(ping)|
|3|0|目的网络不可达|
|3|1|目的主机不可达|
|3|2|目的协议不可达|
|3|3|目的端口不可达|
|3|6|目的网络未知|
|3|7|目的主机未知|
|4|0|源抑制（拥塞控制-未用）|
|8|0|回声请求（ping）|
|9|0|路由通告|
|10|0|路由发现|
|11|0|TTL超期|
|12|0|IP首部错误|

简单介绍完了 `ICMP`，那么抓包过程中出现的 `ARP协议`是什么呢？我们同样来简单解释下：

## ARP协议

我们知道，在一个局域网中，计算机通信实际上是依赖于 MAC地址进行通信的，那么 `ARP（ AddressResolutionProtocol）`的作用就是根据 IP地址查找出对应的 MAC地址。

## Ping过程解析

了解了上面的基础概念后，我们来分析下抓包的数据，其流程如下：

1. A 电脑（ 192.168.2.135）发起 ping请求， ping192.168.2.179

2. A 电脑广播发起 ARP请求，查询 192.168.2.179的 MAC地址。

3. B 电脑应答 ARP请求，向 A电脑发起单向应答，告诉 A电脑自己的 MAC地址为 90:A4:DE:C2:DF:FE

4. 知道了 MAC地址后，开始进行真正的 ping请求，由于 B电脑可以根据A电脑发送的请求知道 源 MAC地址，所以就可以根据源 MAC地址进行响应了。

上面的请求过程我画成流程图比较直观一点：

![](/images/network/1_3.png)

观察仔细的朋友可能已经发现，`Ping` 4次请求和响应结束后，还有一次 B电脑对 A电脑的 `ARP请求`，这是为什么呢？这里我猜测应该是有 2个原因：

- 由于 `ARP`有缓存机制，为了防止 `ARP`过期，结束后重新更新下 ARP缓存，保证下次请求能去往正确的路径，如果 `ARP`过期就会导致出现一次错误，从而影响测试准确性。

- 由于 `ping`命令的响应时间是根据请求包和响应包的时间戳计算出来的，所以一次 `ARP`过程也是会消耗时间。这里提前缓存最新的 ARP结果就是节省了下次 ping的 ARP时间。

为了验证我们的猜测，我再进行一次 `ping`操作，抓包看看是不是和我们猜测的一样。此时，计算机里面已经有了`ARP`的缓存，我们执行 `ARP-a` 看看缓存的arp列表：

![](/images/network/1_4.png)

我们看看第二次 ping的抓包

![](/images/network/1_5.png)

我们看到上图中在真正 `ping`之前并没有进行一次 `ARP`请求，这也就是说，直接拿了缓存中的 `ARP`来执行了，另外当 B计算机进行响应之前还是进行了一次 `ARP请求`，它还是要确认下之前的 `ARP缓存`是否为正确的。然后结束`ping操作`之后，同样再发一次 ARP请求，更新下自己的 `ARP缓存`。这里和我们的猜想基本一致。

弄懂了 `ping` 的流程之后我们来解析下之前解释的 `ICMP数据` 结果是否和抓包的一致。我们来点击一个 ping request看看 ICMP协议详情

![](/images/network/1_6.png)

图中红框内就行 ICMP协议的详情了，这里的 `Type=8,code=0`, 校验是正确，且这是一个请求报文。我们再点击`Responseframe:57`，这里说明响应报文在`序号 57`。详情如下：

![](/images/network/1_7.png)

上图的响应报文， `Type=0,code=0`，这里知道就是响应报文了，然后最后就是根据请求和响应的时间戳计算出来的响应延迟。 `3379.764ms-3376.890ms=2.874ms`。

<br/>

# 总结

<br/>

我们分析了一次完整的 `ping` 请求过程， ping命令是依托于 `ICMP` 协议的， `ICMP`协议的存在就是为了更高效的转发 `IP` 数据报和提高交付成功的机会。 `ping` 命令除了依托于 `ICMP`，在局域网下还要借助于 `ARP协议`， `ARP协议`能根据 `IP地址` 反查出计算机的 `MAC地址`。另外 `ARP` 是有缓存的，为了保证 `ARP的准确性`，计算机会更新 `ARP缓存`。

`Ping` 命令是用来检测网络是否畅通的，而 `Telnet` 命令则用来远程登陆。 但 `Ping` 不通并不一定代表网络不通。`ping` 是基于 `ICMP` 协议的命令，就是你发出去一个数据包，对方收到后返给你一个！就好比声纳。这个协议是可以禁止的！禁止后，如果你 `ping` 对方，对方收到后就不回馈给你，这样你就显示无法 `ping` 通，但实际你们还是连着的！`telnet` 是登陆服务器的！服务没禁止就能登陆。

