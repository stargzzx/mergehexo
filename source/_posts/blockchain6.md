---
title: 区块链 | hashcash
date: 2020-04-26 14:19:35
categories:
- [区块链,基础]
- [密码学,基础]
tags:
- 区块链
- blockchain
---
比特币三大体系支撑之一就是 hash cash。

<!-- more -->

<br/>

# 参考资料

<br/>

[hashcash 算法：从你最熟悉的「验证码」来解释区块链的意义](https://www.chainnews.com/articles/607483180485.htm)
[用 hashcash 打击垃圾邮件](https://www.ibm.com/developerworks/cn/linux/l-hashcash.html)

<br/>

# 写在前面

<br/>

比特币并不是一种新技术。

但比特币绝对是一款创新的产品。在中本聪提出比特币的构想之前，有很多相关的密码学技术已经完成了不少的积累。中本聪的厉害之处在于，他把这几种不同的技术结合起来，针对 P2P 电子现金系统的需求创造出了一款新的产品。从这个意义上来说，中本聪是一个天才的设计师。他是区块链行业里第一个、也是最出名的产品经理。

比特币借鉴了很多现有技术。其中，`POW` （工作量证明）代表的共识机制，借鉴的是 hashcash 算法。`hashcash` 是一种很有趣的设计，从 hashcash 本身的设计结构来看，我们还可以瞥见比特币很多的思想和理念。在这篇文章里，会先稍微介绍下 `hashcash` 的原理，然后从技术的角度来讨论下 `hashcash` 代表了比特币之于传统互联网的意义。

<br/>

# 从验证码开始谈起

<br/>

在解释 `hashcash` 是什么东西之前，我们先来聊点群众们比较熟悉的东西，一个你每天上网都会碰到的、有时还挺招人烦的——验证码。

在我们进行一些安全性比较高的操作时，比如账号登陆、移动支付、购买车票，系统会通过手机短信等验证方式，确认当前操作者的真实身份。

而在另一些安全性不那么高的操作时，比如在贴吧里发个帖子、查询某个数据，有时候也会出现一个验证码。这个验证码通常是一个模糊的图片，让你识别图片里的字母或者汉字，也有技术复杂一点的，可以通过鼠标横滑、鼠标单击的方式来验证。

这种验证码最主要的目的，是判定你是人还是机器。

虽然发帖、查询这些操作本身不具备高安全性要求，但是系统不希望这些操作被不怀好意的人利用，通过大量机器代理账号进行批量操作，发动 `DDoS 攻击`，或者`爬虫`等等。

通过验证码，你把每次操作的成本都往上增加了 1%，这对单个用户来说虽然有点不方便，但总体上还是可以忍受的，但对机器来说，想要进行批量操作，每次识别验证码都要浪费一些时间，这样每次操作叠加起来，想在短时间内批量完成就不可能了。

但读到这里，你可能会跟我有同一种想法：

有人会利用机器批量干坏事，但那是他们的问题，为什么我作为一个遵守规则的用户要为此支付额外的成本？

为什么人们需要因为机器的原因承担验证码的操作成本呢？即使这个操作成本对用户体验的影响很小，但本质上，这还是一个系统设计的问题。

再换个方式想，如果直接让机器像人一样，在每次操作前都进行验证码识别，判断它自己是合法的机器还是非法的机器，这样一来，机器产生的问题不就由机器自己解决了吗？人们完全可以省去验证码的烦恼。

<br/>

# `hashcash` 的设计原理，简单点说就是这样干的

<br/>

为了判断进行操作的机器究竟是合法的还是非法的，最直接的做法，就是让机器自己证明自己的身份。

机器要怎么证明自己呢？

很简单，通过付出一定的成本，来表示自己的可信度。

我们可以认为，如果一个机器愿意付出多少级别的成本，那么它就是真心想进行多少级别的操作。不怀好意的攻击者则会因为机器进行这项操作的成本与收益不合算，从而放弃利用机器进行批量操作的意图。

这个想法应该是可行的。但可行还不够，这套验明机器真身的系统，它的运作效率还应该尽可能更高一些。

所以，如果我们让每台机器在进行操作前都需要计算一个非常复杂的数学问题，通过算力作为机器付出的成本，算出答案的就可以证明自己，那么，系统检验这台机器提交的答案是不是正确答案，这个验证的过程应该尽可能高效。

有什么数学问题是「计算的时候非常麻烦、但是验证的时候非常简单」的？

因数分解算一个。如果你要因数分解一个很大的数字，你可能要花上不少时间去找到它的一组因数。但如果你想知道这组因数是不是正确的答案，把这组数字相乘一下就行了。

<br/>

# hash

<br/>

`hash` （哈希）函数的作用，跟因数分解是差不多的。

`hash` 是一种映射函数，简单来说，它把输入转换成一串特定 ID 输出，这个过程是不可逆的。

比如，如果你用的是比特币的 `SHA-256` 哈希函数，输入「dog」这个单词，就会输出：

	cd6357efdd966de8c0cb2f876cc89ec74ce35f0968e11743987084bd42fb8944

但如果你把这个单词稍微改成「doge」, 那么哈希的结果就会变成：

	c4e793c81ee40370d827d0cbe748d246cffca2cbe959383edf0976d041ece9e5

输入数据即使只改变一个字节，它的 hash 值也会大不相同。

对于一个数据来说，它的 `hash` 值是唯一的，最重要的是，你没有办法从输出的这串数字里面推导破解出原始的输入值。

这样一来，如果给定一台机器一串哈希值，让这台机器去找出符合某些特点的哈希值的原始输入值，你手工计算的话估计找一辈子也找不出来，机器也只能一个值一个值反复去试。如果机器不断穷举，最终碰运气试到了正确答案，那么，机器提交答案时，我想知道你这个答案是不是正确的，只要把这个答案 `hash` 一下，看输出值是不是和要求的一样就行了。也就是说，检验的过程是很简单的。

`hashcash` 就利用了 `hash` 函数的这些特点，让机器不断地尝试不同的数字，找出题目要求的那个值。在实际应用中，我们不需要机器找出某一个特定的哈希值，因为这是不可能的事情（从概率上来说），我们只要求机器找出符合某些条件的哈希值就行，比如，这个条件可以是：哈希值的前二十位都是零。

在比特币里，这个条件则是不断动态变化的，随着时间和矿工的增多，算力要求也越来越多，通过调整题目的难度，我们可以控制机器找到答案的速度，最终保持平均每 10 分钟产出一个区块的速度。

<br/>

# hashcash

<br/>

`hashcash` 的基本原理，抽象出来就是上面所说的那套做法。

在比特币之前，`hashcash` 最广泛的应用是反垃圾邮件。

我们希望，如果需要的话，每个人只要知道 email 地址，就可以直接方便地给我们发邮件。但同时，我们又不希望，一旦自己的 email 地址暴露出去，会被坏人拿去群发垃圾邮件和广告邮件。

如果能让机器在发邮件之前，都需要付出一定的算力来找到正确的哈希数字，那么，每个人依然可以自由的通过 email 发邮件，但那些想用机器批量发垃圾广告的人，就得付出不少代价了。

你可能会问，如果一旦找到正确的哈希数字，机器不就可以一直使用这个数字来群发邮件了？

为了防止这个问题，`hashcash` 要求哈希数字必须包含一个时间戳。

时间戳就像邮戳一样，它代表了这个答案是在什么时候被计算出来的，如果超过一定的时限，这个答案将过期作废。

`hashcash` 让机器在发邮件的时候，需要在发送邮件的数据头部里加入一个字符串 `X-Hashcash` ，这个字符串长这个样子：

	1:bits:date:resource:ext:salt:suffix

`X-Hashcash` 其实就是提交答案的戳记，它包括 7 个域：

- 版本号（版本 0 更简单，但是有一些局限性）。
- 声明的比特值。如果戳记没有真正地使用声明的前导零比特进行散列，那么它就是非法的。
- 生成戳记的日期（和时间）。可以认为当前时间之后的戳记以及那些在很久以前的戳记是非法的。
- 戳记为哪个资源而生成。可能是一个电子邮件地址，但是也可能是一个 URI 或者其他命名的资源。
- 特定应用程序可能需要的扩展。任何附加的数据都可以放置在这里，但是，在到目前为止的使用中， 这个域通常是空的。
- 将该戳记与其他所有人为相同的资源在同一日期生成的戳记区别开来的随机因子（salt）。例如，两个不同的人可以合情合理地在同一天向我的同一个地址发送电子邮件。他们不应该由于我使用了 `double spend` 数据库而无法发送成功。但是，如果他们每个人都使用一个随机因子，那么完整戳记将是不同的。
- 后缀是算法真正起作用的部分。假定给出了前 6 个域，为了生成一个通过期望数目的前导零进行散列的的戳记，`minter` 必须尝试很多连续的后缀值。

我们让邮件加上了证明机器合法性的戳记，这样别人想给你发邮件，他只要像以前那样正常写邮件就行了，机器会自动在后台生成一个戳记附在邮件上，对方接收时只要检查这个戳记是不是合法的，就能决定要不要接收这封邮件了。

这里我解释一下，上面的定义：

- `bits` 这个是宣称前置 0 是多少的，一般使用 16 进制，其中 1 个十六进制代表 4 个 `bit`，假如说， bits = 20 ，那么，前置 0 的数目应该是 5 位
- `suffix` 是计算机计算的概念，我们把前六个域叫做 front ，那么 hash(front + suffix) = info。 而， `info` 的前几位应该是 bits 所宣称的 0。比如，根据上面得到， info 的前 5 位应该是 0。

计算机通过计算 `suffix` ，来使得最后的 `hash` 值符合要求。

<br/>

# 为什么 hash cash 会起作用

<br/>

例如，某个想给我发送消息的人可能会 在消息中包含一个与示例 rfc2822 头文件类似的头文件：

	X-Hashcash: 1:20:040927:mertz@gnosis.cx::odVZhQMP:7ca28

显然，应该由 MUA（邮件用户代理，mail user agents）、过滤器或者 MTA（邮件传输代理，mail transport agents） 来做这件事情，而不是要求用户手工完成。不过，手工完成也不太难，至少实验时如此。首先，通过查看戳记的散列来 校验它，如下所示：

	$ echo -n 1:20:040927:mertz@gnosis.cx::odVZhQMP:7ca28 | sha
	00000b50b85a61e7ba8ac4d5fed317c737706ae5

注意前导零（每一个十六进制数是 4 个比特）。当然，还需要校验哪个资源是您识别出来的那个资源（比如您的收件人地址之一）， 那个戳记还没有被使用过，日期是当前日期。另外，一个合法的戳记拥有的前导零的数目应该与其声明要拥有的数目相同（不过您可以决定强制实行您自己的允许邮件通过的最小代价：20 比特是一个不完全标准（semi-standard），它最终可能会随着 Moore 定律而发生改变）。

生成一个 20-比特的戳记只需要几秒钟的时间。当您一天中只发送几十封电子邮件时，这个代价并不大。但是，对那些 想要发送数百万消息的垃圾邮件制造者来说，不能容忍每条消息使用额外几秒的 CPU 时间。一天之中只有 86,400 秒。即使垃圾邮件制造者利用植入木马（trojans）的僵尸（zombies）的技术，需要使用具体的 hashcash 戳记至少也会减少那些僵尸进程的发出量。 当然，校验一个戳记所需的时间只是一秒的一小部分。

另一方面，向您自己的 MUA 添加 hashcash 生成和校验对其他所有人没有任何负面影响（不像其他一些反垃圾邮件方法）。对那些不使用该协议的接收者而言，这些只是一个他们很容易忽略的附加头文件。对那些没有 添加 hashcash 戳记的发送者而言，检验 X-Hashcash: 的接收者不用校验任何内容。 如果发送者没有添加戳记，那么您的境况不会因为进行检验而变得更糟；也不会因此变得更好。

一个好的 `MUA` 或者垃圾邮件过滤系统可以将拥有合法 hashcash 戳记的电子邮件列入白名单（whitelist）。`SpamAssassin` 甚至更巧妙地为更多合法 `hashcash` 比特提供了更高的 +ve 分数。 我认为，将基于 `bashcash` 的方法应用于白名单是对 `TMDA` 等交互式质询系统的改进 —— 质询消息在返回时不会丢失，发送者不会忘记响应质询。质询响应就在原始消息之中（作为一个 hashcash 戳记）。

<br/>

# `hashcash` 的意义

<br/>

`hashcash` 能让我们知道发送邮件的是一个真实的用户、还是一个群发邮件的广告营销机器。这套方法扩展开来，不止可以应用在反垃圾邮件里，同样，它也可以用在服务器的应答机制里。

我们知道，你通过浏览器输入一串地址，之所以能返回一个固定的网页，得益于 `http` 通信协议的设计。`http` 规定，浏览器发起一个请求，那么服务器就响应这个请求，返回浏览器指定的内容。这个协议本质上非常简单，它不做太多的额外的状态判断，只遵循简单的「一问一答」。

因为 `http` 协议设计太简单，服务器就像一个 email 地址一样，一旦我们知道输入一个网址就可以返回某个资源或者对服务器进行某项操作，我们就可以利用机器批量地给一台服务器连续不断地「写信」。服务器对每个请求都做出回应，最终会消耗大量的服务器资源，从而影响正常用户的访问。这就是 `DDoS 攻击`。

在现实生活中，我们花费了大量的力气来修补类似 `DDoS 攻击`这样的安全问题。我们发明了各种各样的服务器防御机制来判断请求的合法性。但这些方法，都是通过封装一些其他层面的数据和函数来保护服务器，比如反爬虫可能会通过判断短时间内连续访问的 IP 是不是同一个、每次请求的时间是不是小于人们肉身可以操作的速度，从而判定是不是有人借助机器进行批量操作。

这些方法，相当于额外在 `http` 这层协议上再造了一个「安检通道」， `http` 协议本身并不具备「安检」的能力。如果我们能通过 `hashcash`，让 `http` 请求本身自带机器自我证明的信息，这样一来，我们就可以在协议本身的设计上避免类似 `DDoS` 这样的漏洞和攻击。

而这也是区块链技术相比于传统互联网技术最重要的不同点之一。通过区块链、通过 hashcash、通过比特币的共识机制，我们让机器在底层传输协议上活动时都附带上了一些额外的信息，这些额外的信息将被用来证明机器自身的合法性，从而在协议层创造出一个机器与机器之间可以彼此信任的网络环境。

一旦机器与机器之间是可信的，我们就将创造出一个新的互联网。

在这个新的互联网里，机器可以判断其他机器进行请求是否合法，从而使得服务器懂得如何更合理地分配资源。

在这个新的互联网里，我们可以编写新的应用，也就是智能合约，然后把智能合约放心地交给机器自动执行。这套智能合约可以稳定地运作下去，而不必担心网络中有机器不执行智能合约、或者对智能合约进行篡改、出现机器叛徒。这是以太坊诞生的基础。

<br/>

# 总结

<br/>

总而言之，从 `hashcash` 的设计原理出发，我们拥有了另一种对区块链的见解：

比特币和区块链本质上是为了解决机器与机器之间的信任问题。通过保证机器是可信的，从而保证网络的可信度；通过保证网络的可信度，从而使得加入网络的人们能在互信的环境里共同遵守规则，借助 token 和激励机制的设计，最终让人们的个人利益与群体共同利益贴合在一起，最终使得网络的群体都往同一个方向发展。
